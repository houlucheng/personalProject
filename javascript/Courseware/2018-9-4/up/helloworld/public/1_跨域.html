<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <input type="text" id="txt">
<script>
    /*
        ajax

        跨域（源）:
            跳  范围

            源:域名、协议、端口

            同源策略：
                一种约定，它是浏览器最核心也最基本的安全功能

            
            域名:就是ip的一种别称
                www.baidu.com
                www.taobao.com

            协议:
                file,http,https,ftp....

                http://localhost:8082/1_%E8%B7%A8%E5%9F%9F.html
                file:///C:/xampp/php/www/2018-9-4/up/helloworld/public/1_%E8%B7%A8%E5%9F%9F.html

            
            端口：
                像是一个专职柜员，只要在这个柜员上找柜员本身的资源就不存在跨域，否则跨域

            同源:
                同域名、同协议、同端口

            跨域(源):
                不同域名、不同协议、不同端口

            
            http://www.baidu.com

            http://www.baidu.com:80

            http://www.baidu.com:81

            http://www.baidu2.com

            https://www.baidu.com
    
    只要看到了
        Access-Control-Allow-Origin就是跨域

    跨域的解决:
        解决方案有8-9，但是常用的就3个

        1.高版本浏览器的XMLHttpRequest + 后端设置请求头

        2.服务器代理
            需要服务端去跨源访问别的数据,这个服务端文件又和当前同源

            当前 访问服务器文件，就等同于，当前 跨源访问别的数据

        3.jsonp
            json + padding  内填充数据

                1.数据必须是函数名 + 括号的  fn(a)

                2.前端需要在全局定义一个函数去接收数据  function fn(a){a}

                3.是通过script标签去动态请求数据


    */
    txt.onblur = function(){
        let ajax = new XMLHttpRequest
        // ajax.open('get','/get?name='+this.value,true);
        // ajax.open('get','http://localhost:8080/kuayu?name='+this.value,true); //设置请求头
        ajax.open('get','/daili',true); //代理
        ajax.send();
        ajax.onload = function(){
            document.write(ajax.responseText)
            // console.log(JSON.parse(ajax.responseText));
        }
    }

    
</script>
</body>
</html>